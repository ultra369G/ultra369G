<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Singularity Orb</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        canvas {
            display: block;
        }
        .hint {
            position: absolute;
            bottom: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-family: Arial, sans-serif;
            text-align: center;
            width: 100%;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>
<body>
    <canvas id="orbCanvas"></canvas>
    <div class="hint">
        Tilt or move mouse | Shake or click to energize | Bring tabs close to merge
    </div>

    <script>
        // ====== CORE SETUP ======
        const canvas = document.getElementById('orbCanvas');
        const ctx = canvas.getContext('2d');
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        // ====== SINGULARITY ORB ======
        const orb = {
            position: { x: width/2, y: height/2 },
            velocity: { x: 0, y: 0 },
            radius: Math.min(width, height) * 0.25,
            energy: 40, // Start with some energy
            maxEnergy: 150,
            plasmaNodes: [],
            color: { h: Math.random() * 60 + 180, s: 100, l: 60 },
            state: 'idle', // 'idle', 'attracted', 'merging', 'vanishing'
            mergeData: null,
            pulse: 0,
            gravity: 0.5 + Math.random() * 0.5,
            isDominant: false // Will this orb absorb others?
        };

        // ====== PLASMA NODES (Energy Surges) ======
        function initPlasmaNodes() {
            const nodes = 36;
            for (let i = 0; i < nodes; i++) {
                orb.plasmaNodes.push({
                    angle: (i / nodes) * Math.PI * 2,
                    radius: 0.7 + Math.random() * 0.3,
                    speed: 0.02 + Math.random() * 0.03,
                    phase: Math.random() * Math.PI * 2,
                    energy: 0
                });
            }
        }
        initPlasmaNodes();

        // ====== INTERACTION ======
        const motion = {
            gamma: 0,
            beta: 0,
            lastShake: 0
        };

        window.addEventListener('deviceorientation', (e) => {
            motion.gamma = e.gamma || 0;
            motion.beta = e.beta || 0;
            
            // Detect shake to energize
            if (Date.now() - motion.lastShake > 1000) {
                const accel = Math.abs(e.gamma) + Math.abs(e.beta);
                if (accel > 60) energizeOrb();
            }
        });

        window.addEventListener('mousemove', (e) => {
            if (typeof DeviceOrientationEvent === 'undefined' || !DeviceOrientationEvent.requestPermission) {
                motion.gamma = (e.clientX / width - 0.5) * 60;
                motion.beta = (e.clientY / height - 0.5) * 60;
            }
        });

        window.addEventListener('click', energizeOrb);

        function energizeOrb() {
            if (orb.state === 'vanishing') return;
            
            motion.lastShake = Date.now();
            orb.energy = Math.min(orb.maxEnergy, orb.energy + 25);
            orb.color.h = (orb.color.h + 5 + Math.random() * 10) % 360;
            createEnergyWave();
            broadcastState();
        }

        // ====== TAB COMMUNICATION ======
        const tabID = Math.random().toString(36).substr(2, 9);
        let otherOrbs = [];
        const MERGE_DISTANCE = 500; // Pixels between windows to trigger merge

        const channel = new BroadcastChannel('singularity_orb');
        channel.addEventListener('message', (e) => {
            if (e.data.id === tabID) return;

            // Update or add orb data
            const existing = otherOrbs.find(o => o.id === e.data.id);
            if (existing) {
                Object.assign(existing, e.data);
            } else {
                otherOrbs.push(e.data);
                if (e.data.state === 'attracted') createSparkRing();
            }

            // Remove old orbs
            otherOrbs = otherOrbs.filter(o => Date.now() - o.timestamp < 2000);

            // Check for merge conditions
            checkForMerge();
        });

        function broadcastState() {
            channel.postMessage({
                id: tabID,
                x: window.screenX + orb.position.x,
                y: window.screenY + orb.position.y,
                energy: orb.energy,
                color: orb.color,
                state: orb.state,
                isDominant: orb.isDominant,
                timestamp: Date.now()
            });
        }

        function checkForMerge() {
            if (orb.state !== 'idle' && orb.state !== 'attracted') return;

            // Find the closest orb with enough energy
            const closest = otherOrbs.reduce((nearest, other) => {
                if (other.state !== 'idle' && other.state !== 'attracted') return nearest;
                if (other.energy < 20) return nearest;

                const dist = getDistanceToOrb(other);
                if (dist < MERGE_DISTANCE && (!nearest || dist < getDistanceToOrb(nearest))) {
                    return other;
                }
                return nearest;
            }, null);

            if (closest) {
                // The more energetic orb becomes the black hole (absorber)
                if (orb.energy >= closest.energy && !orb.isDominant) {
                    orb.state = 'attracted';
                    orb.isDominant = true;
                    broadcastState();
                } else if (!orb.isDominant) {
                    orb.state = 'attracted';
                    broadcastState();
                }
            }
        }

        function getDistanceToOrb(otherOrb) {
            const dx = otherOrb.x - (window.screenX + orb.position.x);
            const dy = otherOrb.y - (window.screenY + orb.position.y);
            return Math.sqrt(dx * dx + dy * dy);
        }

        // ====== MERGE MECHANICS ======
        function startMerge(targetOrb) {
            if (orb.state === 'merging' || orb.state === 'vanishing') return;

            // The more energetic orb absorbs the other
            if (orb.isDominant) {
                orb.state = 'merging';
                orb.mergeData = {
                    sourceId: targetOrb.id,
                    sourceEnergy: targetOrb.energy,
                    startTime: Date.now()
                };
                channel.postMessage({
                    type: 'merge_request',
                    id: tabID,
                    targetId: targetOrb.id
                });
            }
        }

        // ====== VISUAL EFFECTS ======
        let particles = [];
        let energyWaves = [];

        function createEnergyWave() {
            energyWaves.push({
                x: orb.position.x,
                y: orb.position.y,
                size: orb.radius * 0.5,
                growth: 20,
                life: 1,
                hue: orb.color.h
            });
        }

        function createSparkRing() {
            for (let i = 0; i < 36; i++) {
                particles.push({
                    x: orb.position.x,
                    y: orb.position.y,
                    angle: (i / 36) * Math.PI * 2,
                    speed: 1 + Math.random() * 4,
                    life: 1,
                    size: 1 + Math.random() * 3,
                    hue: orb.color.h
                });
            }
        }

        function createBlackHoleEffect() {
            for (let i = 0; i < 100; i++) {
                particles.push({
                    x: orb.position.x,
                    y: orb.position.y,
                    angle: Math.random() * Math.PI * 2,
                    speed: 0.5 + Math.random() * 3,
                    life: 1 + Math.random(),
                    size: 1 + Math.random() * 4,
                    hue: orb.color.h,
                    spiraling: true
                });
            }
        }

        function updateParticles() {
            // Update energy waves
            energyWaves.forEach(wave => {
                wave.size += wave.growth;
                wave.life -= 0.02;
                wave.growth *= 0.95;
            });
            energyWaves = energyWaves.filter(w => w.life > 0);

            // Update particles
            particles.forEach(p => {
                if (p.spiraling) {
                    p.angle += 0.05;
                    p.speed *= 1.02;
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                } else {
                    p.x += Math.cos(p.angle) * p.speed;
                    p.y += Math.sin(p.angle) * p.speed;
                }
                p.life -= 0.01;
            });
            particles = particles.filter(p => p.life > 0);
        }

        // ====== PHYSICS & ANIMATION ======
        function update() {
            // Update orb physics
            updateOrbPhysics();

            // Update plasma nodes
            updatePlasmaNodes();

            // Update particles
            updateParticles();

            // Energy decay
            if (orb.energy > 10) {
                orb.energy = Math.max(10, orb.energy - 0.1);
            }

            // Broadcast state
            if (Date.now() - (orb.lastBroadcast || 0) > 200) {
                broadcastState();
                orb.lastBroadcast = Date.now();
            }
        }

        function updateOrbPhysics() {
            // Apply tilt forces
            const tiltStrength = 0.02 * (1 + orb.energy / orb.maxEnergy);
            orb.velocity.x += motion.gamma * tiltStrength;
            orb.velocity.y += motion.beta * tiltStrength;

            // Apply magnetic attraction if in 'attracted' state
            if (orb.state === 'attracted') {
                applyAttraction();
            }

            // Apply friction
            const friction = 0.96 - (orb.energy / orb.maxEnergy) * 0.05;
            orb.velocity.x *= friction;
            orb.velocity.y *= friction;

            // Update position
            orb.position.x += orb.velocity.x;
            orb.position.y += orb.velocity.y;

            // Screen boundary bounce
            const bounce = 0.7;
            if (orb.position.x < orb.radius) {
                orb.position.x = orb.radius;
                orb.velocity.x *= -bounce;
                createSparkRing();
            } else if (orb.position.x > width - orb.radius) {
                orb.position.x = width - orb.radius;
                orb.velocity.x *= -bounce;
                createSparkRing();
            }
            if (orb.position.y < orb.radius) {
                orb.position.y = orb.radius;
                orb.velocity.y *= -bounce;
                createSparkRing();
            } else if (orb.position.y > height - orb.radius) {
                orb.position.y = height - orb.radius;
                orb.velocity.y *= -bounce;
                createSparkRing();
            }
        }

        function applyAttraction() {
            const closest = otherOrbs.reduce((nearest, other) => {
                const dist = getDistanceToOrb(other);
                return (!nearest || dist < getDistanceToOrb(nearest)) ? other : nearest;
            }, null);

            if (closest && closest.isDominant) {
                const dx = closest.x - (window.screenX + orb.position.x);
                const dy = closest.y - (window.screenY + orb.position.y);
                const dist = Math.sqrt(dx * dx + dy * dy);
                const force = (orb.gravity * closest.energy) / (dist * 50);

                orb.velocity.x += (dx / dist) * force;
                orb.velocity.y += (dy / dist) * force;

                // If very close, initiate merge
                if (dist < 150) {
                    startMerge(closest);
                }

                // Create connection particles
                if (Math.random() < 0.2) {
                    particles.push({
                        x: orb.position.x,
                        y: orb.position.y,
                        angle: Math.atan2(dy, dx),
                        speed: 2 + Math.random() * 3,
                        life: 0.8,
                        size: 1 + Math.random() * 2,
                        hue: (orb.color.h + closest.color.h) / 2
                    });
                }
            }
        }

        function updatePlasmaNodes() {
            orb.pulse += 0.01;
            const energyFactor = orb.energy / orb.maxEnergy;

            orb.plasmaNodes.forEach(node => {
                node.phase += node.speed * (0.5 + energyFactor);
                node.energy = 0.5 + 0.5 * Math.sin(node.phase) * (0.3 + 0.7 * energyFactor);
            });
        }

        // ====== RENDERING ======
        function render() {
            // Clear with subtle fade
            ctx.fillStyle = 'rgba(0, 0, 10, 0.1)';
            ctx.fillRect(0, 0, width, height);

            // Draw starfield
            drawStarfield();

            // Draw particles
            drawParticles();

            // Draw the orb
            drawOrb();

            // Draw connections to other orbs
            if (orb.state === 'attracted') {
                drawAttractionBeams();
            }
        }

        function drawStarfield() {
            ctx.fillStyle = 'white';
            for (let i = 0; i < 100; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * 1.5;
                const alpha = 0.1 + Math.random() * 0.3;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.fillStyle = `hsla(${p.hue}, 100%, 70%, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            energyWaves.forEach(wave => {
                const gradient = ctx.createRadialGradient(
                    wave.x, wave.y, 0,
                    wave.x, wave.y, wave.size
                );
                gradient.addColorStop(0, `hsla(${wave.hue}, 100%, 70%, ${wave.life * 0.7})`);
                gradient.addColorStop(1, 'hsla(0, 0%, 0%, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(wave.x, wave.y, wave.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawOrb() {
            ctx.save();
            ctx.translate(orb.position.x, orb.position.y);

            // Outer aura
            const auraSize = orb.radius * (1.5 + Math.sin(orb.pulse) * 0.2);
            const auraGradient = ctx.createRadialGradient(
                0, 0, orb.radius * 0.3,
                0, 0, auraSize
            );
            auraGradient.addColorStop(0, `hsla(${orb.color.h}, 100%, 70%, ${0.4 * orb.energy/orb.maxEnergy})`);
            auraGradient.addColorStop(1, 'hsla(0, 0%, 0%, 0)');
            
            ctx.fillStyle = auraGradient;
            ctx.beginPath();
            ctx.arc(0, 0, auraSize, 0, Math.PI * 2);
            ctx.fill();

            // Main orb
            ctx.beginPath();
            ctx.arc(0, 0, orb.radius, 0, Math.PI * 2);
            
            const bodyGradient = ctx.createRadialGradient(
                0, 0, orb.radius * 0.3,
                0, 0, orb.radius
            );
            bodyGradient.addColorStop(0, `hsla(${orb.color.h}, 100%, 80%, 0.9)`);
            bodyGradient.addColorStop(1, `hsla(${orb.color.h}, 100%, 60%, 0.7)`);
            
            ctx.fillStyle = bodyGradient;
            ctx.fill();

            // Plasma nodes
            orb.plasmaNodes.forEach(node => {
                const x = Math.cos(node.angle) * orb.radius * node.radius;
                const y = Math.sin(node.angle) * orb.radius * node.radius;
                const size = orb.radius * 0.1 * node.energy;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                gradient.addColorStop(0, `hsla(${(orb.color.h + 30) % 360}, 100%, 80%, 0.8)`);
                gradient.addColorStop(1, `hsla(${orb.color.h}, 100%, 60%, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Core
            const coreSize = orb.radius * 0.4 * (1 + Math.sin(orb.pulse * 3) * 0.1);
            const coreGradient = ctx.createRadialGradient(
                0, 0, 0,
                0, 0, coreSize
            );
            coreGradient.addColorStop(0, `hsla(${orb.color.h}, 100%, 90%, 0.9)`);
            coreGradient.addColorStop(1, `hsla(${(orb.color.h + 20) % 360}, 100%, 70%, 0.3)`);
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
            ctx.fill();

            // Core flash
            if (orb.energy > 50) {
                const flashSize = coreSize * (1 + (orb.energy/orb.maxEnergy) * 2);
                ctx.fillStyle = `hsla(${orb.color.h}, 100%, 80%, ${0.3 * orb.energy/orb.maxEnergy})`;
                ctx.beginPath();
                ctx.arc(0, 0, flashSize, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        function drawAttractionBeams() {
            otherOrbs.forEach(other => {
                if (other.isDominant) {
                    const dx = other.x - (window.screenX + orb.position.x);
                    const dy = other.y - (window.screenY + orb.position.y);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 600) {
                        const strength = 1 - dist/600;
                        
                        // Energy beam
                        ctx.strokeStyle = `hsla(${orb.color.h}, 100%, 70%, ${0.3 + strength * 0.5})`;
                        ctx.lineWidth = 1 + strength * 3;
                        ctx.beginPath();
                        ctx.moveTo(orb.position.x, orb.position.y);
                        ctx.lineTo(
                            orb.position.x + dx * 0.95,
                            orb.position.y + dy * 0.95
                        );
                        ctx.stroke();
                        
                        // Particles flowing toward the other orb
                        if (Math.random() < strength * 0.3) {
                            const progress = Math.random();
                            const x = orb.position.x + dx * progress;
                            const y = orb.position.y + dy * progress;
                            const size = 1 + Math.random() * 2;
                            
                            ctx.fillStyle = `hsla(${(orb.color.h + other.color.h)/2}, 100%, 80%, ${0.7})`;
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            });
        }

        // ====== ANIMATION LOOP ======
        function animate() {
            update();
            render();
            requestAnimationFrame(animate);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            orb.position.x = width / 2;
            orb.position.y = height / 2;
            orb.radius = Math.min(width, height) * 0.25;
        });

        // iOS permission handling
        if (typeof DeviceOrientationEvent !== 'undefined' && 
            typeof DeviceOrientationEvent.requestPermission === 'function') {
            document.body.addEventListener('click', () => {
                DeviceOrientationEvent.requestPermission()
                    .then(response => {
                        if (response === 'granted') {
                            window.addEventListener('deviceorientation', (e) => {
                                motion.gamma = e.gamma;
                                motion.beta = e.beta;
                            });
                        }
                    })
                    .catch(console.error);
            }, { once: true });
        }

        // Start animation
        animate();
    </script>
</body>
</html>
